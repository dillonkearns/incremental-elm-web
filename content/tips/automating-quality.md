---
type: tip
title: I'm Not a Programmer, I'm an Automator
description: Manageable codebases don't happen because of brilliant designs. They happen because of relentless tiny habits that move code in the right direction.
publishAt: "2020-10-12"
---

Last week I talked about core ingredient to manageable code: [[relentless-tiny-habits]].

Having brilliant code design ideas doesn't necessarily help you manage your codebase better. But building-in relentless, tiny habits is likely to bring out some brilliant designs.

I think we can generalize this one essential technique a step further. Habits are indeed very powerful, and greater than the sum of their parts. But a habit is just a special case of an automation.

Instead of thinking of myself as a programmer, I like to frame my job as an **automator**. Programming is a type of automation. I think you can argue that a habit is a kind of automation as well. It's just that we're automating by training the wiring in our brain instead of automating through code or scripts.

## Who Cares If It's "Programmer" or "Automator"?

It's a subtle distinction. I think the power comes from having clarity on what tasks to prioritize, and how to approach your work. Is manually running a set of deployment steps a good use of time for a Programmer? Perhaps. But it's pretty clear that you're deviating from your job description if you're manually running steps as an "Automator."

Embrace that role, and use that framing of the role as a cue to step back and make a small investment to automate a repetitive task.

## Identifying Automation Opportunities

Automation opportunities can take many forms.

- Organizational/process automation
- Useful code abstractions (for example, UI helper functions instead of repeating UI code)
- Automated tests instead of manual testing
- Shortcut keys instead of repetitive menu navigation

The things to look out for are

- Repetitive steps
- Context shifts
- Quality issues (frequent bugs from a process or area of code)
- Steps to add quality after (rather than [[built-in quality]])

## Some Ways to Automate Your Elm Code

- elm-test
- elm-program-test
- elm-review
- elm-graphql (and other codegen)
- elm-format

These examples may seem obvious because we're used to them. But those tools weren't necessarily obvious before somebody saw that automation opportunity and took action. How can you find similar opportunities in your own codebase? What is slowing you down most in terms of context shifting, repetitive tasks, quality issues, etc.

## Toyota Is Not a Car Manufacturer

Toyota is famous for the saying that they're not a car manufacturing company. They're a car manufacturing improvement company. Their product is not cars, it's their automated, continually improving process for manufacturing cars. Quality cars are the by-product.

In the same way, you can apply [[systems-thinking]] to your code. You improve the results you're getting by improving the process that generates those results.

That doesn't mean you ignore the results. It's essential to drive improvements based on concrete opportunities and pain points, not theoretical or anticipated ones. But once you have something concrete, step back and look at the system, and automate it.

[//begin]: # "Autogenerated link references for markdown compatibility"
[relentless-tiny-habits]: relentless-tiny-habits "relentless-tiny-habits"
[built-in quality]: ../glossary/built-in-quality "built-in-quality"
[//end]: # "Autogenerated link references"
